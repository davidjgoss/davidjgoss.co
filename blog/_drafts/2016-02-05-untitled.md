---
title: Untitled (responsive UI library components)
tags:
- css
- rwd
- design
summary:
  Working on the responsive UI for a specific project is one thing. Creating a responsive UI library that'll be used in as-yet-unknown contexts is something else altogether.
---

[Intro to topic]

Designing a UI library component in isolation is quite a pleasant task. I can tackle its "default" presentation first[^1], then try some different viewport sizes and write alternate styles within media queries where the default stops looking right. Great.

[Representative example with code and screenshots]

[^1]: People often cite "mobile first" here, saying the default should be the smallest variant, but I don't necessarily agree; the default should be whatever takes the least code to write and then undo. For instance, it's *much* simpler in terms of code to style data tables in their tabular form and then use `max-width` media queries to "flatten" them to a single column than try to do it all mobile first. In <del>most</del> many cases, media queries support is a given and you don't need to protect against its absence by doing *everything* mobile first.

Now fast forward to a real project that uses our UI library. My component is being used in the second column of a two-column layout, so it's only got half the width of the viewport. Suddenly, the work with media queries I did in the UI library is rendered useless - worse, in fact, because now the styles that are supposed to make it look right from 600px are being applied in 300px of space, and it doesn't look right at *any* viewport size.

I've been designing and building this UI library at the same time as designing screens for a relatively large application that's going to consume it. This has been a good process --- each entity has informed and influenced the other --- and because of it, the issue of responsive variants not working presented itself pretty quickly.

## So, what's the solution?

The concept of container queries, where you would be able to write alternate styles for a component based on the dimensions of *the container it's in* would solve this problem. In fact, container queries (or "element queries" as some call them) would be nothing short of revolutionary to the world of UI libraries.

In the case of our component from earlier, we could use container queries instead of media queries to wrap the alternate styles, so instead of saying "when the viewport is 600px wide or more, apply these styles", we'd be saying "when the component is in 600px of space or more, apply these styles". Then, it wouldn't matter where in a project the component got dropped into - two columns, three columns, whatever -- it would just work. Perfect!

Unfortunately, container queries are probably never going to happen. [Elaborate]

## So...what's the solution?

Mixins are the solution.

Obviously, I'm making a fairly large assumption at this point that any serious UI library is going to be using a CSS preprocessor (Sass or LESS, doesn't matter). Yes, preprocessors are a double-edged sword and people can make a mess by abusing extends and so on, but your UI library is important and its source should be carefully controlled, and contributions well-reviewed.

With our example component, we can pull out the 600px styles into a mixin, so the library itself is only implementing the default presentation, but providing the tools to apply the responsive variants as required.

Whilst working this way will ensure your UI library doesn't ship with counter-productive responsive behaviour, it does mean that in the majority of cases things won't "just work" out of the box --- that is, you'll tend to have to use the mixins to make a component look right in your project's context, rather than just chuck it in. You could worry about whether people working on the consuming projects will get this right, but instead spend that time writing documentation so you can help them get it right.





